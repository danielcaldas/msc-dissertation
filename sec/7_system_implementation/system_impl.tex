Here we present the system specifications such as which technologies we use in each component by drawing a new architecture diagram that specifies what technologies are used in each part of the system.

\section{Implementation first steps}
In this section we will describe out approach towards the implementation of the system, we will describe the process since the requirements
definition to the technological choices, some challenges and implementation details.

For gathering requirements we simply defined two groups, the first, the system Back-end has essential base functionalities, we focused only
on the essential without scoping or prioritizing, all the collected requirements are in the progress of being implemented, these include
web crawling modules, data mining for some data treatment and an extraction manager that allows remote calls of parameterized (granular) extractions.
In the system Front-end we followed a different approach by collecting a larger group of requirements that consist mainly in user interactions with the tool,
allowing us to narrow down the essential features based on requirements comparison. So at the end we sum up a few \textit{must have} requirements that
define the system identity an reflect the principles on which the project was designed upon (accessibility, simplicity, \glspl{osn} integration and contextual analysis).\\

\indent From here we built a simple \textit{proof of concept} that demonstrates the most basic of the workflow, this consists in a few steps that we next list:
\begin{itemize}
    \item \textbf{Back-end} - Extract users from a \glspl{osn} (for this particular case we used Facebook as source);
    \item \textbf{Service Aggregator} - Aggregate the extracted users in a graph respecting front end data contract;
    \item \textbf{Front-end} - Rendering a graph on the browser, allow simple interaction of node data display on the user mouse click.
\end{itemize}

\subsection*{Aside note}
As one may noticed in the previous list, for sake of objectivity we skipped the implementation of some pieces in the architecture,
namely, the network metrics \gls{api} and the data mining process, these will only be included in the full implementation, because for the current proof
of concept we labeled this components as complements (this may be seen as add ons or plugins that added to proof of concept will bring the
project to life).\\

\subsection{Proof of concept results}
\indent These steps previously listed steps prove that the designed architecture produces the expected results, furthermore we also conclude in an empiric way what are
the best tools and technologies that better suite the project requirements.\\

\begin{figure}[h!]
\begin{center}
  \hspace*{-0.8in}
  \includegraphics[width=1.2\textwidth]{img/proof-of-concept.png}
\end{center}
\caption{\label{img:poc} A \textit{screenshoot} of our first proof of concept.}
\end{figure}

\indent In the Figure \ref{img:poc}, we can observe a network being rendered, this represents the friendship network of a given user. Since there is an entry point user, if we let him in this network we would obtain a egocentric network that could not depict all the surrounding relations in this small society. What we did was remove this node in order to obtain more clarity to observe the network. At Figure \ref{img:poc} we also can see the interaction of clicking on a certain node and displaying the node information.

\section{Choose of Technologies}
Having the requirements been defined and a small proof of concept being developed as we see in the previous section, we are now able to present our technological choices and provide some context on how we came to these conclusions. We will divide the presentation into four main sections where we present technologies specific to an application layer, starting from database technologies until we reach the front end technologies. For each section we first list the technologies and then we present the motives that lead us to that specific choices.

\subsection{Database technologies}
\begin{itemize}
    \item \textbf{MongoDB}.
\end{itemize}

Relational databases are one of the complex and advanced technologies that we have today. We have been building our applications on top of these technologies with very strict rules that allow our data to remain coherent through applications lifetimes. Databases engines such as MySQL, PostgreSQL and SQL Server are good live examples of the relevance of these technologies. Meanwhile, applications have grown not just in size but also in complexity, the \textit{web era} came, and with it the need for tools that allow us to manage unstructured data. Other alternatives to relational databases have emerged, today known as \textbf{non relational databases} (also known as NoSQL databases). These are database engines that better allow us to store unstructured data or store data in a non relational way.\\
\indent We use a \textbf{MongoDB} (\cite{mongodb}) (a document oriented database) to store data, this gives us more flexibility in manipulating complex JSON structures that are persisted in documents. These flexibility and interoperability would be considerably more complex to achieve using relational databases.

\subsection{Back-end technologies}
\begin{itemize}
    \item \textbf{Flask};
    \item \textbf{Python},
    \item \textbf{NetworkX};
    \item \textbf{PhantomJS};
    \item \textbf{Selenium WebDriver};
    \item \textbf{XPath}.
\end{itemize}

The main language that will support our back-end is \textbf{Python}, this conclusion came very naturally since Python is one of the most used programming languages in the data science field along with others such as R or Java. We also choose Python for two other main reasons: first, we will be building data scrapper modules that need to simulate browser interactions, for that we will use \textbf{Selenium WebDriver} (\cite{documentation2013selenium}) for browser automation and interaction (with the complement of \textbf{PhantomJS}(\cite{hidayat2013phantomjs}) a headless browser with a Javascript API), and Python integrates very naturally with these technologies, along side with \textbf{XPath} (\cite{clark1999xml}) for querying HTML pages and narrow extraction to the essentials; second because \textbf{NetworkX} that (\cite{hagberg2013networkx}), that was already presented in Chapter 4, is written in Python and is a Python module. NetworkX is the most popular and powerful library that offers a large range of metrics and algorithms to run against graphs that come \textit{out of the box}.\\
\indent For networking, to make our back-end services available through web \glspl{api}, we will use \textbf{flask} (\cite{ronacher2015flask}), a micro-framework for building simple networking applications in Python.

\subsection{Middleware technologies}
\begin{itemize}
    \item \textbf{NodeJS};
\end{itemize}

Sometimes we just need something very specific to perform some networking middleware operations, for this purpose NodeJS (\cite{nodejs}) is an emerging technology
that has been famous for performing well this kind of tasks. For bridging between our back-end and front-end we might need some small pieces that act
as \textit{glue} between these two larger components, we will use NodeJS for that purpose.

\subsection{Front-end technologies}
\begin{itemize}
    \item \textbf{HTML};
    \item \textbf{Javascript}
    \item \textbf{CSS};
    \item \textbf{D3.js};
    \item \textbf{React};
\end{itemize}

Since we are building a web application, we automatically address to three main technologies that need no introduction, these are HTML, Javascript and CSS. In complement, we will use for, our specific needs that consist in building interactive graphs, a web data driven document representation system, \textbf{D3.js} (\cite{bostock2012d3}). In what concerns to visualization D3.js will be our main third party, that will bring us many features to help us on network representation and graph interaction \footnote{in our proof of concept we already used D3.js for rendering the network as we have demonstrated in Figure \ref{img:poc}}. In order to improve front-end performance and development process a modern web component based library was choosed, React REACT\_REF.

\section{Implementation architecture}

In the diagram of Figure XXX, we may find our system architecture now with the respective technology attached. In order to understand the most important interactions we will present in the following sections two sequence diagrams that describe two major end to end interactions (meaning what happens when the user performs some action in the system, and what actually happens under the hood in order to obtain a certain final result).

\subsection{Network Aggregation and Rendering}

\begin{figure}[h!]
\begin{center}
  \hspace*{-0.8in}
  \includegraphics[width=1.2\textwidth]{img/socii-sd.jpg}
\end{center}
\caption{\label{img:sociisd} In this figure we may observe Socii sequence diagram for building a network.}
\end{figure}

\begin{huge}
Do the diagram first, then implement then write.
\end{huge}
In the diagram of figure XXX, on may observe what happens since the user requests that a certain \glspl{osn} network is built.
First the user configures the network choosing the number of nodes for a certain \gls{osn} and what metrics he wants to calculate against the network
and then see in the network visualizer area. Then the user presses the \textit{"Build Network"} button, and for some undetermined amount of time
the application only displays a spinner to the user. From the front-end the first request was \textbf{POST /generate-network} to the service aggregator, the service aggregator generates a network, collects users from the \textbf{network generator} service, and returns a raw representation of the network (raw meaning that it only contains nodes and links) so that the user may be the most immediately as possible the network. At the same time that the user sees the network gaining form and the nodes positioning themselves a new request is made by the front-end ....

\subsection{Community detection with node coloring by property...?}
\begin{huge}
Do the diagram first, then implement then write... same as above
\end{huge}

\section{Implementation details}
In this section we explore for each system component some important implementation details not yet mentioned such as:
\begin{itemize}
    \item Code overview and architecture;
    \item Most relevant 3rd parties that were used;
    \item Deployment process.
    \item ...
\end{itemize}


% ...
% \subsection{[PLACEHOLDER] Extraction and data mining}
% ...
% \subsection{[PLACEHOLDER] Network metrics}
% ...
% \subsection{[PLACEHOLDER] Front-end and service aggregator}
%
% \subsubsection{Graph render and interaction component}
% https://danielcaldas.github.io/react-d3-graph/sandbox/index.html
% Talk about the component, why it was built how it is going to be integrated in Socci tool.
\subsubsection{react-d3-graph: software component for graph visualization [PLACEHOLDER]}
\begin{quote}
\textit{"React component to build interactive and configurable graphs with d3 effortlessly"}
\end{quote}

From an end user perspective one of the most relevant and valuable aspect of a \glspl{sna} tool are powerful network interactions and clean visualization (and by clean we mean perceptible). In order to achieve this in Socii our efforts were directed into a generic, reusable and configurable software: \textbf{react-d3-graph} REF\_RD3G\_GITHUBREPO. This component allows us to focused only on the visualization features and in how we want to represent and interact with our network (graph). This component is built on top of the react library and creates configurable abstractions upon D3.js. All the detailed documentation of react-d3-graph
may be consulted on the web REF\_RD3G\_DOCS, also a live demo with the all the possible public configurations offered by react-d3-graph is also available in the web REF\_SANDBOX.\\
With this development we will isolate all the visualization concerns leaving Socii with less work on this matter, also socii can wrap this component and use the available user actions to interact with the graph, and all the visual aspects such as nodes colors or text size may or may not be editable by a Socii user, Socii has the power to decide the level of granularity of user control upon graph configurations, but of course since we want a simple application we will leave it to Socii on how the network looks like exposing some basic interactions to the end user such as node click, zooming, mouse overing and drag and drop on all the network or upon a specific node.

